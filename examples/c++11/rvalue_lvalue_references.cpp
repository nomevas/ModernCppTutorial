// lvalue, left value, as the name implies, is the value to the left of the assignment symbol. To be precise, an lvalue is a persistent object that still exists after an expression
// (not necessarily an assignment expression). Rvalue, right value, the value on the right refers to the temporary object that no longer exists after the expression ends.

// In C++11, in order to introduce powerful rvalue references, the concept of rvalue values ​​is further divided into: prvalue, and xvalue.
// pvalue, pure rvalue, purely rvalue, either purely literal, such as 10, true; either the result of the evaluation is equivalent to a literal or anonymous temporary object, for
// example 1+2. Temporary variables returned by non-references, temporary variables generated by operation expressions, original literals, and Lambda expressions are all pure
// rvalue values. xvalue, expiring value is the concept proposed by C++11 to introduce rvalue references (so in traditional C++, pure rvalue and rvalue are the same concepts), a
// value that is destroyed but can be moved.

#include <gtest/gtest.h>

#include <functional>

TEST(RLValueReferences, Basic) {
  struct TestStruct {
    static std::string reference(std::string& str) { return "lvalue"; }
    static std::string reference(std::string&& str) { return "rvalue"; }
  };

  std::string input;
  EXPECT_EQ("lvalue", TestStruct::reference(input));
  EXPECT_EQ("rvalue", TestStruct::reference("temp_object"));
  EXPECT_EQ("rvalue", TestStruct::reference(input + " something new"));
}

TEST(RLValueReferences, RValue_ConstRef_ExtendLifespan) {
  std::string s1 = "s1";
  std::string s2 = "s2";

  const std::string& res1 = s1 + s2;
  std::string&& res2 = s1 + s2;
  // std::string& lv2 = s1 + s2;  ERROR: initial value of reference to non-const must be an lvalue

  EXPECT_EQ("s1s2", res1);
  EXPECT_EQ("s1s2", res2);
}

struct PerfectForwardingStruct {
  static std::string reference(auto&& str) { return std::is_rvalue_reference_v<decltype(str)> ? "rvalue" : "lvalue"; }
};

TEST(RLValueReferences, PerfectForwarding) {
  std::string input;
  EXPECT_EQ("lvalue", PerfectForwardingStruct::reference(input));
  EXPECT_EQ("rvalue", PerfectForwardingStruct::reference(std::string{"temp_object"}));
  EXPECT_EQ("rvalue", PerfectForwardingStruct::reference(input + " something new"));
}